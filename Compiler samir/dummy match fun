bool Matcher::fun(string str, D_state* start){
    /**try to match string str*/
    vector<D_state*> path;
    /*get the start state*/
    //set<D_state*>::iterator start = DFA.begin();
    /*temp use as iterator*/
    D_state * temp = start;
    D_state * s = start;
    path.push_back(temp);
    for(std::string::size_type i = 0; i < str.size(); ++i)
    {
        /*follow the sequance of str chars*/
        temp = temp->get_next(str[i]);
        /*add to path to save steps*/
        path.push_back(temp);
    }
    /*once exit str for loop = check if temp is acceptance state */
    if(temp->is_accept())
    {
        /*get the type matched from temp name*/
        string type = temp->get_name();
        /*write pattern in the output file*/
        this->out = this->out + type + '\n';
        if(type == "id")
        {
            /*add to sym table*/
            this->symbol_table.push_back(str);
        }
        return true;
    }
    else                /*not matched*/
    {
        /*try to go back until reach an acceptance state*/
        int iter = (int)path.size();
        while(!temp->is_accept() && iter > 0)
        {
            temp = path[iter-1];
            iter--;
        }
        /*once i get there -> temp is accepted or iter = 0*/
        if(temp->is_accept())
        {
            /*i reach to an acceptance state*/
            /*get the type matched from temp name*/
            string type = temp->get_name();
            /*write pattern in the output file*/
            this->out = this->out + type + '\n';
            if(type == "id")
            {
                /*add to sym table*/
                this->symbol_table.push_back(str);
            }
            /*seperate str and call back fun again with the reminder*/
            string reminder = str.substr (iter+1);
            return this->fun(reminder, start);
        }
        else if(iter <= 0 && !temp->is_accept() )           /* not matched or try delete from start */
        {

            if(this->error_recovery(str,start))
            {
                /*deleted from start done :D and write good in file*/
            }
            else
            {
                /*generate error to output file*/
                this->out = this->out + "ERROR in symbol  " + str + '\n';
                return false;
            }
        }
        else
        {
            /*generate error to output file*/
            this->out = this->out + "ERROR in symbol  " + str + '\n';
            return false;
        }
    }
    path.clear();
}
